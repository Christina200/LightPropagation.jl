var documenterSearchIndex = {"docs":
[{"location":"Nlayer_cyl/#Light-Diffusion-in-a-N-layered-turbid-cylinder","page":"N-layer Cylinder","title":"Light Diffusion in a N-layered turbid cylinder","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"The salient features and their implementation of Liemert and Kienle's[1] solution to the diffusion equation for the N-layered finite cylinder are discussed. ","category":"page"},{"location":"Nlayer_cyl/#Helpful-Background-Reading:","page":"N-layer Cylinder","title":"Helpful Background Reading:","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Light diffusion in a turbed cylinder. I. Homogoeneous case[2]\nLight diffusion in a turbed cylinder. II. Layered case[1]\nNoninvasive determination of the optical properties of two-layered turbid media[3]\nLight diffusion in N-layered turbid media: steady-state domain[4]\nLight diffusion in N-layered turbid media: frequency and time domains[5]","category":"page"},{"location":"Nlayer_cyl/#Nomenclature:","page":"N-layer Cylinder","title":"Nomenclature:","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"We follow the solution for a point beam incident onto the center top of the first layer of N-layered cylinders with radii a. In cylindrical cooridnates vecr=(rho phi z) the source position can be defined as vecr_0=(00z_0) where z_0 is the assumed position of an isotropic source at a distance z_0 = frac1mu_s1. We ignore the absorption term but if desired can be redefined in the diffusionparams function. The thickness, refractive index, reduced scattering and absorption coefficients of layer k are denoted by l_k n_k mu_s_k mu_a_k, respectively. The extrapolated boundary condition is used with the extrapolation length z_b_k = 2 A_k D_k where A_k reflection factor calculated from the angle-averaged probability for reflection at a boundary between layer k and the surrounding medium. We calculate A_k from the polonomial approximation listed in Contini 1997 but can be calculated in anyway by altering the get_afac function. Finally, the diffusion coefficient in layer k is D_k = 1(3mu_s).","category":"page"},{"location":"Nlayer_cyl/#Solution","page":"N-layer Cylinder","title":"Solution","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"The solution for the fluence in the first layer Phi_1(vecr omega) for a point source incident onto the center of the cylinder top can then be described by Equation 22 in Ref 1. [1]","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Phi_1(vecr) = frac1pi a^2 sum_n=1^infty G_1(s_n z) J_0(s_n rho)J_1^-2(a s_n)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Where a = a + z_b_k, rho is the source-detector separation, and J_m is the Bessel function of the first kind and order m. More interestingly, s_n are the roots of J_m satisfying J_m(a s_n) = 0qquad n = 1 2 . For an incident source on the center top, the summation over all orders of J_m is no longer needed so we only need to consider m=0. s_n then becomes the roots to Bessel function of the first kind and zero order. It should be noted that both J_0 and J_1 appear in the solution but this is because the general solution is in the form of J_m and J_m+1. For those familiar with the trickier case presented in [3] and then extended in [4] and [5] this is main contribution to the accuracy, stability, and speed of the solutions. For those unfamilar, the decisive point is the numerically correct and efficient 2-D inverse Fourier transform of Phi(z s) must be calculated to obtain the fluence in real space Phi(vecr) (directly taking language from Liemert here). I would say this is most easily implemented by taking advantage of rotational symmetry and using the 1-D inverse Hankel Transform. In contrast, the nodes of the integral are not fixed like in the cylindrical case presented here, but is solved by adaptive Gauss integration. If the nodes were consistent, they could be precomputed and used for each case but the amount of nodes and their location depend on the forward parameters in the model. All this to say, precalculating the roots and storing them is highly efficient and significantly more accurate and stable. The roots are divided by a for each new condition.","category":"page"},{"location":"Nlayer_cyl/#Green's-function","page":"N-layer Cylinder","title":"Green's function","text":"","category":"section"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Finally, the Green's function in the first layer G_1(s_n z) is:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"G_1(s_n z) = frace^-alpha_1 z - z_0 - e^-alpha_1 (z + z_0 + 2z_b_1)2D_1 alpha_1 + fracsinhalpha_1(z_0 + z_b_1) sinhalpha_1(z + z_b_1)D_1alpha_1 e^alpha_1(l_1 + z_b_1) 5pt\ntimes fracD_1alpha_1n_1^2beta_3 - D_2alpha_2n_2^2gamma_3D_1alpha_1n_1^2beta_3coshalpha_1(l_1 + z_b_1) + D_2alpha_2n_2^2gamma_3sinhalpha_1(l_1 + z_b_1)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Where alpha_k has the form in the steady-state:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"alpha_k = sqrts_n^2 + fracmu_a_kD","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Whereas a complex term is added in the Frequency Domain:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"alpha_k = sqrts_n^2 + fracmu_a_kD + fraciomegaDc","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"As you can notice the first term of G_1(s_n z) contains exponentially decaying functions which is great as you can see that alpha has to be summed for very large numbers. Generally z z_b z_0 are around 0.1 so this is easy to handle computationally. On the other hand, terms like sinhalpha l and coshalpha l go to infinity very quickly. It is much better to define (though messier) the Green's function in terms of exponetials using sinhx = (e^x - e^-x)2 and coshx = (e^x + e^-x)2. After some algebraic manipulation we can then define G_1(s_n z) as:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"G_1(s_n z) = frace^-alpha_1 z - z_0 - e^-alpha_1 (z + z_0 + 2z_b_1)2D_1 alpha_1 + frace^alpha_1(z_0 + z - 2l_1)1 - e^-2alpha_1(z_0 + z_b_1)2D_1alpha_1 5pt\ntimes fracD_1alpha_1n_1^2beta_3 - D_2alpha_2n_2^2gamma_3D_1alpha_1n_1^2beta_31 + e^-2alpha_1(l_1 + z_b_1) + D_2alpha_2n_2^2gamma_31 - e^-2alpha_1(l_1 + z_b_1)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"Great. So now we have expressed the Green's function in terms of exponentially decaying functions instead of dividing by exponentially growing functions so we are confident that we won't get overflow errors as alpha goes to infinity. We are now ready to discuss the last pesky thing which are the gamma_3 and beta_3 factors. These are generally obtained from recurrence relations in [1] by equation 17 and 18. As presented they also contain exponentially growing functions. Where before we only had sinhalpha_1 l_1 now we have exponential functions of all the layers. This is especially challenging if we consider the bottom layer to be large. In general the same procedure we used prior should be used but we can't explicitly write them in terms of decaying functions because these factors actually do exponentially increase. What we can do is take advantage of the way they present in G_1(s_n z) which is (beta_3 - gamma_3)(beta_3 + gamma_3). We need to find a common exponentially growing factor that presents in both coefficients that we can then cancel.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"After we factor a common term out we can then define the coefficients for an N-layered cylinder as :","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N = 2:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_3 = 1 - e^-2 alpha_2 (l_2 + z_b_2) 5pt\ngamma_3 = 1 + e^-2 alpha_2 (l_2 + z_b_2)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N = 3:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_3 = D_2 alpha_2 n_2^2 (1 + e^-2alpha_2 l_2)(1 - e^-2 alpha_3 (l_3 + z_b_2)) + D_3 alpha_3 n_3^2 (1 - e^-2alpha_2 l_2)(1 + e^-2 alpha_3 (l_3 + z_b_2)) 5pt\ngamma_3 = D_2 alpha_2 n_2^2 (1 - e^-2alpha_2 l_2)(1 - e^-2 alpha_3 (l_3 + z_b_2)) + D_3 alpha_3 n_3^2 (1 + e^-2alpha_2 l_2)(1 + e^-2 alpha_3 (l_3 + z_b_2))","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N = 4:","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_4 = D_3 alpha_3 n_3^2 (1 + e^-2alpha_3 l_3) (1 - e^-2alpha_4 (l_4 + z_b_2) + D_4 alpha_4 n_4^2 (1 - e^-2alpha_3 l_3) (1 + e^-2alpha_4 (l_4 + z_b_2) 5pt\ngamma_4 = D_3 alpha_3 n_3^2 (1 - e^-2alpha_3 l_3) (1 - e^-2alpha_4 (l_4 + z_b_2) + D_4 alpha_4 n_4^2 (1 + e^-2alpha_3 l_3) (1 + e^-2alpha_4 (l_4 + z_b_2) ","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_3 = D_2 alpha_2 n_2^2 beta_4 (1 + e^-2alpha_2 l_2) + D_3 alpha_3 n_3^2 gamma_4 (1 - e^-2alpha_2 l_2) 5pt\ngamma_3 = D_2 alpha_2 n_2^2 beta_4 (1 - e^-2alpha_2 l_2) + D_3 alpha_3 n_3^2 gamma_4 (1 + e^-2alpha_2 l_2)","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"N  4: Use start values","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_N = D_N-1 alpha_N-1 n_n-1^2 (1 + e^-2alpha_N-1l_N-1)(1 - e^-2alpha_N-1(l_N-1 + z_b_2)) 5pt\n + D_N alpha_N n_n^2 (1 - e^-2alpha_N-1l_N-1)(1 + e^-2alpha_N(l_N + z_b_2)) 10pt\ngamma_N = D_N-1 alpha_N-1 n_n-1^2 (1 - e^-2alpha_N-1l_N-1)(1 - e^-2alpha_N-1(l_N-1 + z_b_2)) 5pt\n + D_N alpha_N n_n^2 (1 + e^-2alpha_N-1l_N-1)(1 + e^-2alpha_N(l_N + z_b_2))","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"With downward recurrence relations: ","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"beta_k - 1 = D_k - 2 alpha_k - 2 n_k - 2^2 (1 + e^-2alpha_k - 2l_k - 2) beta_k + D_k - 1 alpha_k - 1 n_k - 1^2 (1 - e^-2alpha_k - 2l_k - 2) gamma_k 5pt\ngamma_k - 1 = D_k - 2 alpha_k - 2 n_k - 2^2 (1 - e^-2alpha_k - 2l_k - 2) beta_k + D_k - 1 alpha_k - 1 n_k - 1^2 (1 + e^-2alpha_k - 2l_k - 2) gamma_k","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[1]: Liemert, André, and Alwin Kienle. \"Light diffusion in a turbid cylinder. II. Layered case.\" Optics Express 18.9 (2010): 9266-9279.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[2]: Liemert, André, and Alwin Kienle. \"Light diffusion in a turbid cylinder. I. Homogeneous case.\" Optics Express 18.9 (2010): 9456-9473.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[3]: Kienle, Alwin, et al. \"Noninvasive determination of the optical properties of two-layered turbid media.\" Applied optics 37.4 (1998): 779-791.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[4]: Liemert, André, and Alwin Kienle. \"Light diffusion in N-layered turbid media: steady-state domain.\" Journal of biomedical optics 15.2 (2010): 025003.","category":"page"},{"location":"Nlayer_cyl/","page":"N-layer Cylinder","title":"N-layer Cylinder","text":"[5]: Liemert, André, and Alwin Kienle. \"Light diffusion in N-layered turbid media: frequency and time domains.\" Journal of biomedical optics 15.2 (2010): 025002.","category":"page"},{"location":"whensemiinf/#*When-is-semi-infinite-semi-infinite?*","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"","category":"section"},{"location":"whensemiinf/#Learning-outcomes:","page":"When is semi-infinite semi-infinite?","title":"Learning outcomes:","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Simulate the time-domain reflectance under the diffusion approximation for semi-finite, slab, and parralelepiped geometries\nUtilize the non-linear curve fitting functions to extract optical properties from simulated experimental data\nGain physical intuition of approximations and how to apply them","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"info: Disclaimer\nThe following is not a recommendation on when to apply certain approximations as that would depend on     experimental setup and application. Please use this as an introduction to the software.","category":"page"},{"location":"whensemiinf/#Loading-LightPropagation.jl","page":"When is semi-infinite semi-infinite?","title":"Loading LightPropagation.jl","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Let's begin by loading the package into the current environment. This can be done as below or as shown on the main page.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"using Pkg\nPkg.add(url = \"https://github.com/heltonmc/LightPropagation.git\")\nusing LightPropagation","category":"page"},{"location":"whensemiinf/#Forward-Models","page":"When is semi-infinite semi-infinite?","title":"Forward Models","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The functions we are using to simulate the TPSF for the semi-infinite, slab, and parallelpiped geometries are:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"TPSF_DA_semiinf_refl\nTPSF_DA_slab_refl\nTPSF_DA_paralpip_refl","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"tip: Available Functions\nTo view all the available functions is is often useful to check the exported functions in the main file. For example if you go to ~/LightPropagation/src/LightPropagation.jl in the repository you will find export TPSF_DA_semiinf_refl lines that indicate available functions.","category":"page"},{"location":"whensemiinf/#Semi-infinite","page":"When is semi-infinite semi-infinite?","title":"Semi-infinite","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Let's simulate the TPSF for a semi-infinite medium under the following conditions:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"t = 0:0.01:5 (ns)\nβ = [0.1, 10.0] – β[1] and β[2] are the absorption and reduced scattering coefficient (1/cm)\nρ = 1.0 – source-detector separation (cm)\nndet = 1.0 – index of refraction of detector\nnmed = 1.0 – index of refraction of medium","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"t = 0.01:0.01:5\nTPSF_semiinf = TPSF_DA_semiinf_refl(t, [0.1,10.0], 1.0, 1.0, 1.0)","category":"page"},{"location":"whensemiinf/#Slab","page":"When is semi-infinite semi-infinite?","title":"Slab","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Let's simulate the TPSF for a slab (bounded in the z-direction) for two thicknesses (2cm and 8cm) with the same optical properties and SDS as simulated for the semi-infinite medium. The inputs are the same as the semi-infinite geometry with an additional input for the slab thickness.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"TPSF_slab_2cm = TPSF_DA_slab_refl(t, [0.1,10.0], 1.0, 1.0, 1.0, 2.0)\nTPSF_slab_8cm = TPSF_DA_slab_refl(t, [0.1,10.0], 1.0, 1.0, 1.0, 8.0)","category":"page"},{"location":"whensemiinf/#Parallelepiped","page":"When is semi-infinite semi-infinite?","title":"Parallelepiped","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The parralelepiped geometry is bounded in the x, y, and z direction. Check the difference in input arguments by typing ? TPSF_DA_paralpip_refl into the REPL. You can see that the inputs are slightly different than the slab and semi-infinite geometry. Instead of listing the SDS we need to specify the location of the source and detector in x, y coordinates. Here, rd is the x, y location of the source on the top surface, and rs is the location of the detector on the top source. These are measured from the corner. Let's have two cubes one with L = 8cm and L = 4cm with the source located in the center so that rs = [4.0, 4.0] and [2.0, 2.0] respectively. We want the detector to be 1cm from the source to match SDS in previous examples. Below they are defined as rd = [3.0, 4.0] and [1.0, 2.0].        ","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"TPSF_paralpip_8cm = TPSF_DA_paralpip_refl(t, [0.1,10.0], 1.0, 1.0, [3.0,4.0], [4.0,4.0], [8.0,8.0,8.0])\nTPSF_paralpip_4cm = TPSF_DA_paralpip_refl(t, [0.1,10.0], 1.0, 1.0, [1.0,2.0], [2.0,2.0], [4.0,4.0,4.0])","category":"page"},{"location":"whensemiinf/#Compare-all-three-geometries","page":"When is semi-infinite semi-infinite?","title":"Compare all three geometries","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Now let's compare and visualize all 5 of the curves we have simulated as shown below:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"using Plots\nplot(t, TPSF_semiinf, yscale=:log10, lw = 10, ylabel=\"Counts\", xlabel=\"time (ns)\", label=\"TPSF_semiinf\")\nplot!(t, TPSF_slab_2cm, lw = 2, label = \"TPSF_slab_2cm\")\nplot!(t, TPSF_slab_8cm, lw = 4, label = \"TPSF_slab_8cm\", c=\"black\")\nplot!(t, TPSF_paralpip_8cm, lw = 2, label = \"TPSF_paralpip_8cm\", alpha = 0.9)\nplot!(t, TPSF_paralpip_4cm, lw = 2, label = \"TPSF_paralpip_4cm\", alpha = 0.9)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"(Image: modelcomparison)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Great. Now change the input parameters for each curve (optical properties and SDS) to investigate different domains. Here, for this set of optical properties and SDS the  semi-infinite approximation matches exactly the slab solution when the slab thickness is 8cm (for t < 5ns), though it would be a poor approximation for thin samples (2cm). The parallelepiped geometry also matches the semi-infinite geometry when its sides are greater than 8cm, though there are some differences at longer time scales. In practice, experimental systems would not have enough dynamic range to fit over such large changes in intensity.","category":"page"},{"location":"whensemiinf/#Key-Takeaways","page":"When is semi-infinite semi-infinite?","title":"Key Takeaways","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Good agreement at the earliest times (<1ns) where the boundary effects are minimized. \nFor confined geometries, (e.g. TPSF_paralpip_4cm and TPSF_slab_2cm) we see there are significant differences compared to the semi-infinite approximations.\nIf the boundaries are significantly away from the source the semi-infinite approximation appears to be a good approximation.\nIf the underlying media is a parralelepiped, would a semi-infinite geometry under or overestimate the optical properties? Hint: Changes in absorption mainly affect the later times, while scattering dominates early arrival times.","category":"page"},{"location":"whensemiinf/#Inverse-Problem","page":"When is semi-infinite semi-infinite?","title":"Inverse Problem","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Now that we have visually observed the differences between the three geometries, let's investigate and try to quantify the error when using the models in the inverse problem to extract optical properties.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The first thing we must do is simulate some experimental data to fit. In practice, samples are not infinite so let's use the parralelepiped geometry as the ground 'truth' and let's fit all three models to that curve. You can add noise (follows a poisson distribution) if you would like, but let's assume no noise for now.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"ydata = TPSF_DA_paralpip_refl(t, [0.1,10.0], 1.0, 1.0, [0.5,1.5], [1.5,1.5], [3.0,3.0,3.0])","category":"page"},{"location":"whensemiinf/#Setup-Inverse-problem","page":"When is semi-infinite semi-infinite?","title":"Setup Inverse problem","text":"","category":"section"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"The first thing we must do is set up the input data and model parameters. The input data is your experimental known parameters. Here, these will be two separate data structures with different fields. There will be required fields that you must enter and fields that will default if you don't define them. ","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"You must specify the time scale, the experimental DTOF, and the IRF. Depending on your geometry, you would then specify the SDS, index of refraction of medium and detector, the slab thickness, or the parallelepiped dimensions. Since we know the dimensions of the cube (assuming these are known), and because we are testing the model with all three approximations we need to specify each field. If you were just using a semi-infinite approximation you would only have to specify (t, DTOF, IRF, and ρ). ","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Before we can define our data structure we must define the IRF. We must also define our model parameters which take the analytical model you are fitting with, the fit ranges, the initial guess for the inverse fitting procedures as well as upper and lower bounds. If you don't define these they will use the default values. (The model normalizes the photon counts, so we have normalized the ydata)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"\n#Define the IRF as a delta function length of ydata\nIRF = [1; zeros(length(ydata) - 1)]\n\n# Define a structure called data with the specified fields \ndata = fitDTOF(t = t, DTOF = ydata./maximum(ydata), IRF = IRF, ρ = 1.0, nmed = 1.0, ndet = 1.0, s = 3.0, rd = [0.5,1.5], rs = [1.5,1.5], L = [3.0,3.0,3.0])\n\n# Define the fitting parameters called m for parallepiped geometry\nm = DTOF_fitparams(model = TPSF_DA_paralpip_refl, risefactor = 0.01, tailfactor = 1e-10,initparams = [0.05, 20.0])\n\n# Define model with semi-inf  approximation\nm1 = DTOF_fitparams(model = TPSF_DA_semiinf_refl, risefactor = 0.01, tailfactor = 1e-10, initparams = [0.05, 20.0])\n\n#Define model with slab approximation\nm2 = DTOF_fitparams(model = TPSF_DA_slab_refl, risefactor = 0.01, tailfactor = 1e-10, initparams = [0.05, 20.0])\n\n#Fit data with the three models\nf, tfit, yraw, yfit  = getfit(data, m)\nf1, tfit1, yraw1, yfit1  = getfit(data, m1)\nf2, tfit2, yraw2, yfit2  = getfit(data, m2)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"As shown the getfit function returns four separate variables. f will be the fit structure where you can call the fitting parameters and residuals, t will be the time scale the fit happened on, and the yraw data that was fit to, and the resulting yfit.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Let's plot these below to see how they look.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"scatter(tfit, yraw, m=\"*\", ms = 8, label = \"ydata\", c=\"black\")\nplot!(tfit, yfit, lw = 3, alpha = 1, label = \"paralpip model\", c=\"blue\")\nplot!(tfit1, yfit1, lw = 3, alpha = 1,label = \"semiinf model\", c=\"red\")\nplot!(tfit2, yfit2,lw = 3, alpha = 1, label = \"slab model\", c=\"orange\")\nplot!(ylabel=\"Counts\", xlabel=\"time (ns)\")","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"(Image: fitcomparison)","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"To check the extracted optical properties we can call the param field of our fit result like:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"f.param # [0.0999999 9.999999]\nf1.param # [0.158778 13.51499]\nf2.param # [0.153302 12.61908]","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"We can see that when using the semi-infinite approximation (f1) results in 59% error in the extracted absoprtion coefficient and 35% error in the extracted reduced scattering coefficient. The error when using the slab approximation (f2) is 53% and 26% respectively. Utilizing the parallelepiped geometry returned the exact properties. Remember that we are fitting over a large range where the difference at long time scales can be significant. Most of the time fitting only occurs at 1 or 0.1% on the falling tail. Change the fitting parameters in your model to see how it can improve or decrease in accuracy depending on fit range.","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"Note: If you are just wanting to fit using a semi-infinite or slab geometry you do not need to specify the data structure as defined earlier. Whatever model you define in the parameter structure will call the appropriate inputs. For example if you just wanted to fit a semi-infinite model you can define data and m as below:","category":"page"},{"location":"whensemiinf/","page":"When is semi-infinite semi-infinite?","title":"When is semi-infinite semi-infinite?","text":"data = fitDTOF(t = t, DTOF = ydata./maximum(ydata), IRF = IRF, ρ = 1.0, nmed = 1.0, ndet = 1.0)\nm = DTOF_fitparams(model = TPSF_DA_semiinf_refl, risefactor = 0.01, tailfactor = 1e-10,initparams = [0.05, 20.0])","category":"page"},{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Installation-requirements","page":"Getting Started","title":"Installation requirements","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"LightPropagation is tested on MacOS and Linux, but it should be also possible to use it on Windows since it is written exclusively in Julia and it only depends on registered Julia packages.","category":"page"},{"location":"getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"The easiest way to install julia is by downloading julia from the offical site and following the platform specific installations. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Launch Julia and open Julia's package manager by typing ] in the REPL. You should see the command line change from julia> to (@v1.5) pkg>. (The @v1.x will display your current version) Add the package as shown in the code block below. Once the package has cloned, backspace to bring back the julia> in your REPL and type using LightPropagation as shown below.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"(@v1.5) pkg> add \"https://github.com/heltonmc/LightPropagation.git\"\n\njulia> using LightPropagation\n","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"For further information about how to install and manage Julia packages, see the Pkg documentation.","category":"page"},{"location":"getting-started/#Forward-Simulation","page":"Getting Started","title":"Forward Simulation","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"To view a functions inputs and methods type ? in the REPL and then the name of the function. Let's first look at simulating a temporal point spread function (TPSF) for a semi-infinite medium.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"help?> TPSF_DA_semiinf_refl\nsearch: TPSF_DA_semiinf_refl\n\n  TPSF_DA_semiinf_refl(t, β::Array{Float64,1}, ρ::Float64, ndet::Float64, nmed::Float64)\n\n  Compute the time-domain reflectance from a semi-infinite medium. \n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡≡≡\n\n    •    t: the time vector (ns). \n\n    •    β::Array{Float64,1}: the optical properties μa, μs' (cm⁻¹)\n\n    •    ρ::Float64: the source detector separation (cm⁻¹)\n\n    •    ndet::Float64: the boundary's index of refraction (air or\n        detector)\n\n    •    nmed::Float64: the sample medium's index of refraction\n\n  Examples\n  ≡≡≡≡≡≡≡≡≡≡\n\n  julia> TPSF_DA_semiinf_refl(0:1:5, [0.1,10.0], 1.0, 1.0, 1.0)\n  6-element Array{Float64,1}:\n   0.0\n   0.0001440103022493725\n   1.446739954231315e-6\n   2.7354735244571076e-8\n   6.794070985483474e-10\n   1.9657536202689858e-11","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This is a convenient way to see a brief description of the function and its arguments. Let's call this function and set it equal to a variable called TPSF. We can also plot this with the below example. ","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"\njulia> using Plots\n\njulia> t = 0:0.01:10\njulia> TPSF = TPSF_DA_semiinf_refl(t, [0.1,10.0], 1.0, 1.0, 1.0)\njulia> ind = TPSF .> 0\n\njulia> plot(t[ind], TPSF[ind], yscale=:log10, lw = 2, ylabel=\"Counts\", xlabel=\"time (ns)\", label=\"TPSF\")\n","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"There are several other forward models in different geometries. The naming scheme of the forward models follow a physicalquantity_approximation_geometry_measurementtype scheme. So something that simulates the reflected temporal point spread function using the diffusion approximation for a semi-infinite geometry would be TPSF_DA_semiinf_refl . Try simulating the TPSF for a slab and parralelepiped geometry by using TPSF_DA_slab_refl and TPSF_DA_paralpip_refl functions.","category":"page"},{"location":"DA_slab_semiinfgeom/#Solutions-of-the-Diffusion-Equation-for-the-Slab-Geometry","page":"Slab","title":"Solutions of the Diffusion Equation for the Slab Geometry","text":"","category":"section"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"The following describes the light propagation through turbid media bounded by parallel planes. ","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"The described derivations follow the methods from Contini 1997.[1]","category":"page"},{"location":"DA_slab_semiinfgeom/#Diffusion-Equation","page":"Slab","title":"Diffusion Equation","text":"","category":"section"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"(frac1nufracpartial partial t - Dnabla^2 + mu_a)Phi(vecr t) = Q(vecr t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Where Q(vecr t) is the isotropic source term and D is the diffusion coefficient, D = frac13mu_s","category":"page"},{"location":"DA_slab_semiinfgeom/#Solution-of-the-Diffusion-Equation-for-homogeneous-media-in-a-slab-geometry","page":"Slab","title":"Solution of the Diffusion Equation for homogeneous media in a slab geometry","text":"","category":"section"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"The diffusion equation is a partial-differential equation that will require boundary conditions to solve for a specific geometry. Here we will utilize the extrapolated boundary conditions as described in Contini 1997.[1] that assumes that the flux is equal to 0 on an extrapolated surface at a distance of (2AD). After the boundary conditions have been determined, utilizng the method of images will allow us to reconstruct the fluence inside the medium. ","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Utilizing Equation 33 from Contini 1997,[1] the time-dependent Green's function for the fluence rate at (vecr) can be described by:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Phi(vecr t) = fracnu(4pi D nu t)^frac32\nexp(- fracrho ^24 D nu t - mu_a nu t) times\nsum_m=-infty^m=+infty exp(-frac(z-z_m^+)^24 D nu t) - \nexp(-frac(z-z_m^-)^24 D nu t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Where:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"z_m^+ = 2m(s+ 2z_e)\nz_m^- = 2m(s +2z_e) - 2z_e - z_s\nm = 0 pm 1 pm 2  pm infty","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"To obtain solutions for the time-dependent transmittance and reflectance we can utilize Fick's law where:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"R (rho t) = Dfracpartialpartial z Phi(rho z = 0 t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"and ","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"T (rho t) = - Dfracpartialpartial z Phi(rho z = s t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Which yields Equation 36 from Contini 1997[1] for the time-dependent reflectance on the surface:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"R(rho t) = - fracexp(-mu_a nu t - fracrho^24 D nu t)2(4pi D nu)^frac32t^frac52\ntimes\nsum_m=-infty^m=+infty z_3mexp(-fracz_3m^24 D nu t) - \nz_4mexp(-fracz_4m^24 D nu t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"and Equation 39 from Contini 1997.[1] for the time-dependent transmittance on at the distance z=s where s is the thickness of the slab:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"T(rho t) = fracexp(-mu_a nu t - fracrho^24 D nu t)2(4pi D nu)^frac32t^frac52\ntimes\nsum_m=-infty^m=+infty z_1mexp(-fracz_1m^24 D nu t) - \nz_2mexp(-fracz_2m^24 D nu t)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"Where:","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"z_1m = s(1-2m) - 4mz_e - z_o\nz_2m = s(1-2m) - (4m-2)z_e - z_o\nz_3m = -2ms - 4mz_e - z_o\nz_4m = -2ms - (4m-2)z_e - z_o","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"To obtain solution","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"λ0 = 1 #doesn't matter since everything is normalized to λ0\nk0 = 2π/λ0\nkin = 3k0\nθ_i = 0.0 #incident wave is left->right\npw = PlaneWave(θ_i)\nN = 260\nP = 10\nshapes = [rounded_star(0.1λ0, 0.05λ0, 5, N)]\nids = [1] # the particle at centers[1,:] has the parametrization shapes[ids[1]]\ncenters = [0.0 0.0] # our particle is centered at the origin\nφs = [0.0] #zero rotation angle\nsp = ScatteringProblem(shapes, ids, centers, φs)","category":"page"},{"location":"DA_slab_semiinfgeom/","page":"Slab","title":"Slab","text":"[1]: Daniele Contini, Fabrizio Martelli, and Giovanni Zaccanti, \"Photon migration through a turbid slab described by a model based on diffusion approximation. I. Theory,\" Appl. Opt. 36, 4587-4599 (1997) ","category":"page"},{"location":"#LightPropagation.jl","page":"Home","title":"LightPropagation.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LighPropagation provides a set of tools for modeling light transport in turbid media written in the Julia programming language. The main motivation behind the development of this library is to provide an easy-to-use, open-source framework that highlights and standardizes prominent analytical techniques to model light transport in complex heterogenous structures. The radiative transport equation (RTE) and its approximations to model propagation of particles in random media are frequently applied in astrophysics, nuclear physics, biophotonics, heat transfer, computer graphics, and climate research. This package focuses on their use in biomedical optics with a focus on performance and standardization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The library has two main components split into (a) the forward modelling of light transport and (b) the associated inverse problem. Currently, photon migration in the continuous-wave (CW), frequency-domain (FD)and time-domain (TD) under the Diffusion Approximation (DA) are described in homogenous media for semi-infinite, slab, and parallelepiped geometries. Laterally infinite multi-layered solutions are also described. Least squares fitting based on the Levenberg-Marquardt algorithm are also available to fit time-resolved measurements after convolution with the Instrument Response Function (IRF). ","category":"page"},{"location":"#Julia-educational-resources","page":"Home","title":"Julia educational resources","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A basic knowledge of the Julia programming language is needed to use the LightPropagation package. Here, one can find a list of resources to get started with this programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Official webpage docs.julialang.org\nOfficial list of learning resources julialang.org/learning\nOfficial YouTubechannel","category":"page"},{"location":"#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"DA_slab_semiinfgeom.md\",\n  ]","category":"page"},{"location":"API/#Diffusion-Approximation","page":"API","title":"Diffusion Approximation","text":"","category":"section"},{"location":"API/#Infinite","page":"API","title":"Infinite","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_inf_CW\nfluence_DA_inf_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_inf_CW","page":"API","title":"LightPropagation.fluence_DA_inf_CW","text":"fluence_DA_inf_CW(ρ, μa, μsp)\n\nCompute the steady-state fluence in an infinite medium. \n\nArguments\n\nρ: source-detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\n\nExamples\n\njulia> fluence_DA_inf_CW(1.0, 0.1, 10.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_inf_TD","page":"API","title":"LightPropagation.fluence_DA_inf_TD","text":"fluence_DA_inf_TD(t, ρ, μa, μsp; nmed = 1.0)\n\nCompute the time-domain fluence in an infinite medium with Eqn. 3 of Patterson. et al. 1989. \n\nArguments\n\nt: the time vector (ns). \nρ: source-detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_med::Float64: medium's index of refraction\n\nExamples\n\njulia> fluence_DA_inf_TD(0.1:0.5:5.0, 1.0, 0.1, 10.0, n_med = 1.4)\n\n\n\n\n\n","category":"function"},{"location":"API/#Semi-infinite","page":"API","title":"Semi-infinite","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_semiinf_CW\nfluence_DA_semiinf_TD\nflux_DA_semiinf_CW\nflux_DA_semiinf_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_semiinf_CW","page":"API","title":"LightPropagation.fluence_DA_semiinf_CW","text":"fluence_DA_semiinf_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0)\n\nCompute the steady-state fluence in a semi-infinite geometry according to Eqn. 3 of Kienle 1997. \n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nz: the z-depth orthogonal from the boundary (cm)\n\nExamples\n\njulia> fluence_DA_semiinf_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_semiinf_TD","page":"API","title":"LightPropagation.fluence_DA_semiinf_TD","text":"fluence_DA_semiinf_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, z = 0.0)\n\nCompute the time-domain fluence in a semi-infinite medium (Eqn. 33 Contini). \n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nz: the z-depth in medium\n\nExamples\n\njulia> fluence_DA_semiinf_TD(0.1:0.1:1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_semiinf_CW","page":"API","title":"LightPropagation.flux_DA_semiinf_CW","text":"flux_DA_semiinf_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)\n\nCompute the steady-state flux (D*∂ϕ(ρ)/∂z @ z = 0) from a semi-infinite medium.\n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nndet: the boundary's index of refraction (air or detector)\nnmed: the sample medium's index of refraction\n\nExamples\n\njulia> `flux_DA_semiinf_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0)`\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_semiinf_TD","page":"API","title":"LightPropagation.flux_DA_semiinf_TD","text":"flux_DA_semiinf_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0)\n\nCompute the time-domain flux (D*∂ϕ(t)/∂z @ z = 0) from a semi-infinite medium from Eqn. 36 Contini 97 (m = 0).\n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_det: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\n\nExamples\n\njulia> `flux_DA_semiinf_TD(1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0)`\n\n\n\n\n\n","category":"function"},{"location":"API/#Slab","page":"API","title":"Slab","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_slab_CW\nfluence_DA_slab_TD\nflux_DA_slab_CW\nflux_DA_slab_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_slab_CW","page":"API","title":"LightPropagation.fluence_DA_slab_CW","text":"fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0, xs = 10)\n\nCompute the steady-state fluence from a slab geometry (x, y -> inf, z -> finite). \n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth within slab (cm)\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_slab_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_slab_TD","page":"API","title":"LightPropagation.fluence_DA_slab_TD","text":"fluence_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 10)\n\nCompute the time-domain fluence from a slab geometry (x, y -> inf, z -> finite). \n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth coordinate (cm)\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_slab_TD(0.1, 1.0, 0.1, 10.0, s = 40.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_slab_CW","page":"API","title":"LightPropagation.flux_DA_slab_CW","text":"fluence_DA_slab_CW(ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0, xs = 10)\n\nCompute the steady-state flux, D*∂ϕ(ρ)/∂z for z = 0 and -D*∂ϕ(ρ)/∂z for z = s from a slab geometry (x, y -> inf, z -> finite).\nIf z != 0 or s will default to compute D*∂ϕ(ρ)/∂z for the z given.\n\nArguments\n\nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth within slab (cm)\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> `flux_DA_slab_CW(1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, s = 2.0, z = 0.0)`\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_slab_TD","page":"API","title":"LightPropagation.flux_DA_slab_TD","text":"flux_DA_slab_TD(t, ρ, μa, μsp; n_ext = 1.0, n_med = 1.0, s = 1.0, z = 0.0, xs = 15)\n\nCompute the time-domain flux, D*∂ϕ(t)/∂z for z = 0 and -D*∂ϕ(t)/∂z for z = s from a slab geometry (x, y -> inf, z -> finite).\nIf z != 0 or s will default to compute D*∂ϕ(t)/∂z for the z given.\n\nArguments\n\nt: the time vector (ns). \nρ: the source detector separation (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\ns: the thickness (z-depth) of the slab (cm)\nz: the z-depth coordinate (cm)\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> flux_DA_slab_TD(1.0, 1.0, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, z = 0.0, s = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#Parallelepiped","page":"API","title":"Parallelepiped","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_paralpip_CW\nfluence_DA_paralpip_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_paralpip_CW","page":"API","title":"LightPropagation.fluence_DA_paralpip_CW","text":"fluence_DA_paralpip_CW(μa, μsp; n_ext = 1.0, n_med = 1.0, rd = [4.0, 5.0, 0.0], rs = [5.0, 5.0], L = [10.0, 10.0, 10.0], xs = 10)\n\nCompute the steady-state fluence in a parallelepiped [lx, ly, lz].\n\nArguments\n\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nrd: target location within medium [x,y,z] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nrs: the location of the source [x,y] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nL: the dimensions [lx, ly, lz] of the parallelepiped\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_paralpip_CW(0.1, 10.0, n_ext = 1.0, n_med = 1.0, rd = [24.0, 25.0, 0.0], rs = [25.0,25.0], L = [50.0,50.0,50.0], xs = 20)\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_paralpip_TD","page":"API","title":"LightPropagation.fluence_DA_paralpip_TD","text":"fluence_DA_paralpip_TD(t, μa, μsp; n_ext = 1.0, n_med = 1.0, rd = [4.0, 5.0, 0.0], rs = [5.0, 5.0], L = [10.0, 10.0, 10.0], xs = 10)\n\nCompute the time-domain fluence in a parallelepiped [lx, ly, lz].\n\nArguments\n\nt: the time vector (ns). \nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nrd: target location within medium [x,y,z] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nrs: the location of the source [x,y] with origin x,y = 0 at corner of parallelepiped; z assumed to be 0\nL: the dimensions [lx, ly, lz] of the parallelepiped\nxs: the number of sources to compute in the series\n\nExamples\n\njulia> fluence_DA_paralpip_TD(0.5, 0.1, 10.0, n_ext = 1.0, n_med = 1.0, rd = [24.0, 25.0, 0.0], rs = [25.0,25.0], L = [50.0,50.0,50.0], xs = 20)\n\n\n\n\n\n","category":"function"},{"location":"API/#Layered-Cylinder","page":"API","title":"Layered Cylinder","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"fluence_DA_Nlay_cylinder_CW\nfluence_DA_Nlay_cylinder_TD\n\nflux_DA_Nlay_cylinder_CW\nflux_DA_Nlay_cylinder_TD","category":"page"},{"location":"API/#LightPropagation.fluence_DA_Nlay_cylinder_CW","page":"API","title":"LightPropagation.fluence_DA_Nlay_cylinder_CW","text":"fluence_DA_Nlay_cylinder_CW(ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots)\n\nCompute the steady-state fluence in an N-layered cylinder. Source is assumed to be located on the top middle of the cylinder.\n\nArguments\n\nρ: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nl: layer thicknesses (cm)\na: cylinder radius (cm)\nz: source depth within cylinder\nbesselroots: roots of bessel function of first kind zero order J0(x) = 0\n\nExamples\n\njulia> fluence_DA_Nlay_cylinder_CW(1.0, [0.1, 0.1], [10.0, 10.0], 1.0, [1.0, 1.0], [4.5, 4.5], 10.0, 0.0, besselroots)\n\n\n\n\n\nfluence_DA_Nlay_cylinder_CW(data, besselroots)\n\nWrapper to fluenceDANlaycylinderCW(ρ, μa, μsp, next, nmed, l, a, z, besselroots) with inputs given as a structure (data).\n\nExamples\n\njulia> data = Nlayercylinder(a = 10.0, l = [1.0, 1.0, 1.0, 2.0], z = 5.0) julia> `fluenceDANlaycylinder_CW(data, besselroots)`\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.fluence_DA_Nlay_cylinder_TD","page":"API","title":"LightPropagation.fluence_DA_Nlay_cylinder_TD","text":"fluence_DA_Nlay_cylinder_TD(t, ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots; N = 24, ILT = hyper_fixed)\n\nCompute the time-domain fluence in an N-layered cylinder. Source is assumed to be located on the top middle of the cylinder. It is best to use hyper_fixed as the inverse laplace transform if t consists of many time points. Utilize hyperbola for a single time point. The value of N should be proportional to the dynamic range of the time-domain signal needed. For later times you will need a larger N. The lowest fluence value you can compute will be no less than the machine precision you utilize. Float64 values are limited to fluence > ~2.2-16.\n\nArguments\n\nt: time point or vector (ns)\nρ: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nl: layer thicknesses (cm)\na: cylinder radius (cm)\nz: source depth within cylinder\nbesselroots: roots of bessel function of first kind zero order J0(x) = 0\nN: number of Hankel-Laplace calculations\nILT: inverse laplace transform function\n\nExamples\n\njulia> fluence_DA_Nlay_cylinder_TD(0.1:0.1:2.0, [0.1, 0.1], [10.0, 10.0], 1.0, [1.0, 1.0], [4.5, 4.5], 10.0, 0.0, besselroots)\n\n\n\n\n\nfluence_DA_Nlay_cylinder_TD(data; besselroots, ILT = hyper_fixed)\n\nWrapper to fluenceDANlaycylinderTD(t, ρ, μa, μsp, next, nmed, l, a, z, besselroots; N = 24, ILT = hyper_fixed) with inputs given as a structure (data).\n\nExamples\n\njulia> data = Nlayercylinder(a = 10.0, l = [1.0, 1.0, 1.0, 2.0], z = 5.0) julia> `fluenceDANlaycylinder_TD(0.5:1.0:2.5, data, besselroots)`\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_Nlay_cylinder_CW","page":"API","title":"LightPropagation.flux_DA_Nlay_cylinder_CW","text":"flux_DA_Nlay_cylinder_CW(ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots)\n\nCompute the steady-state flux using Fick's law D[1]∂ϕ(ρ)/∂z for z = 0 (reflectance) and -D[end]∂ϕ(ρ)/∂z for z = sum(l) (transmittance) in an N-layered cylinder.  Source is assumed to be located on the top middle of the cylinder. z must be equal to 0 or the total length sum(l) of cylinder.\n\nArguments\n\nρ: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nl: layer thicknesses (cm)\na: cylinder radius (cm)\nz: source depth within cylinder: must be equal to 0 or sum(l)\nbesselroots: roots of bessel function of first kind zero order J0(x) = 0\n\nExamples\n\njulia> flux_DA_Nlay_cylinder_CW(1.0, [0.1, 0.1], [10.0, 10.0], 1.0, [1.0, 1.0], [4.5, 4.5], 10.0, 0.0, besselroots)\n\n\n\n\n\nflux_DA_Nlay_cylinder_CW(data, besselroots)\n\nWrapper to fluxDANlaycylinderCW(ρ, μa, μsp, next, nmed, l, a, z, besselroots) with inputs given as a structure (data).\n\nExamples\n\njulia> data = Nlayercylinder(a = 10.0, l = [1.0, 1.0, 1.0, 2.0], z = 5.0) julia> `fluxDANlaycylinder_CW(data, besselroots)`\n\n\n\n\n\n","category":"function"},{"location":"API/#LightPropagation.flux_DA_Nlay_cylinder_TD","page":"API","title":"LightPropagation.flux_DA_Nlay_cylinder_TD","text":"flux_DA_Nlay_cylinder_TD(t, ρ, μa, μsp, n_ext, n_med, l, a, z, besselroots; N = 24)\n\nCompute the time-domain flux using Fick's law D[1]∂ϕ(ρ, t)/∂z for z = 0 (reflectance) and -D[end]∂ϕ(ρ, t)/∂z for z = sum(l) (transmittance) in an N-layered cylinder.  Source is assumed to be located on the top middle of the cylinder. z must be equal to 0 or the total length sum(l) of cylinder. Uses the hyperbola contour if t is an AbstractFloat and the fixed hyperbola contour if t is an AbstractVector. ∂ϕ(ρ, t)/∂z is calculated using forward mode auto-differentiation with ForwardDiff.jl\n\nArguments\n\nt: time point or vector (ns)\nρ: source-detector separation in cylindrical coordinates (distance from middle z-axis of cylinder) (cm⁻¹)\nμa: absorption coefficient (cm⁻¹)\nμsp: reduced scattering coefficient (cm⁻¹)\nn_ext: the boundary's index of refraction (air or detector)\nn_med: the sample medium's index of refraction\nl: layer thicknesses (cm)\na: cylinder radius (cm)\nz: source depth within cylinder\nbesselroots: roots of bessel function of first kind zero order J0(x) = 0\nN: number of Hankel-Laplace calculations\n\nExamples\n\njulia> fluence_DA_Nlay_cylinder_TD(0.1:0.1:2.0, [0.1, 0.1], [10.0, 10.0], 1.0, [1.0, 1.0], [4.5, 4.5], 10.0, 0.0, besselroots)\n\n\n\n\n\nflux_DA_Nlay_cylinder_TD(t, data; besselroots, N = 24)\n\nWrapper to fluxDANlaycylinderTD(t, ρ, μa, μsp, next, nmed, l, a, z, besselroots; N = 24) with inputs given as a structure (data).\n\nExamples\n\njulia> data = Nlayercylinder(a = 10.0, l = [1.0, 1.0, 1.0, 2.0], z = 5.0) julia> `fluxDANlaycylinder_TD(0.5:1.0:2.5, data, bessels = besselroots[1:600])`\n\n\n\n\n\n","category":"function"}]
}
